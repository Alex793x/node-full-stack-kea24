{
  "code": "// asynchronous code:\n// Browser event handlers, network calls, buffers / streams, \n// working with files / directories, setTimeout / setInterval, \n// databases\n\n// Javascript one thread - the main thread \n\n// Solution 1. Callbacks\n// Problem: Callback hell, Pyramid of Doom\n\n// Solution 2. Promises\n// states: \n// 1. Pending\n// 2. Fulfilled \n//     - resolved\n//     - rejected\n\n// Solution 3. Async/Await\n// syntactic sugar \n\nnew Promise((resolve, reject) => {\n    setTimeout(() => {\n        try {\n            // throw new Error(\"some error\");\n            const functionReference = () => \"NICE\";\n            resolve(functionReference)\n        } catch (error) {\n            // console.log(error);\n            reject(error);\n        }\n    }, 2000);\n})\n// .then((successMessage) => console.log(successMessage()))\n// .catch((errorMessage) => console.log(errorMessage));\n\n\n/* assignment  Create a promisified function\nthat is, a function that returns a new promise\nthe function should be called myPromise\nand it should either resolve as \"Something Good\" or reject as \"Something Bad\" \ncreate a 3 second timeout to simulate asynchronous behavior\n*/\n\n\nfunction myPromise() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n        try {\n            throw \"Oh NO\";\n            resolve(\"Something Good\");\n        } catch (error) {\n            console.log(error);\n            reject(\"Something Bad\");\n        }\n        }, 3000);\n    });\n}\n\n// myPromise()\n// .then((successMessage) => console.log(successMessage))\n// .catch((errorMessage) => console.log(errorMessage));\n\n/* assignment\n    try to simulate the fetch function\n    call it myFetch\n    it should return the promise json() so that you can call response.json() on it\n    as much as possible try to imagine how fetch works and simulate the underlying code\n*/\n\nfunction myFetch(URL, options={}) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            try {\n                resolve({\n                    json: () => new Promise((resolve, reject) => resolve(\"Response from server\"))\n                });\n            } catch {\n                reject();\n            }\n        }, 2500);\n    });\n}\n\n// myFetch(\"https://www.domain.com\")\n// .then((response) => response.json())\n// .then((result) => console.log(result));\n\n\n\n// IIFE\n(async () => {\n    try {\n        const myPromiseResult = await myPromise();\n        console.log(myPromiseResult);\n        return myPromiseResult;\n    } catch (error) {\n        console.log(error);\n    }\n})()\n\n\n\n// async function wrapper() {\n//     const result = await main();\n//     console.log(result);\n// }\n// wrapper();\n\n\n"
}